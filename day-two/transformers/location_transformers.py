#!/usr/bin/env python3
"""
Auto-generated transformation functions for ES Address__c to BBF Location__c migration.

Generated by: transformation-generator agent
Date: 2026-01-15T17:10:04.350819
Source: ES_Address__c_to_BBF_Location__c_mapping.xlsx

Usage:
    from transformers.location_transformers import TRANSFORMERS, apply_transformers

    # Apply single transformer
    bbf_value = TRANSFORMERS['CLLICode_Last_Part__c'](es_record['nan'])

    # Apply all transformers
    bbf_record = apply_transformers(es_record)
"""

import re
from typing import Any, Optional
from datetime import datetime, date


# Picklist value mappings
ADDRESS_VALIDATED_BY_MAP = {
    'SmartyStreets': 'SmartyStreets',
    'Google Maps': 'Google Maps',
    'UPS': 'UPS'
}

BUSINESSUNIT_MAP = {
    'Cleveland': 'Cleveland',
    'Columbus': 'Columbus',
    'Detroit': 'Detroit',
    'Harrisburg': 'Harrisburg',
    'Illinois': 'Illinois',
    'Indiana': 'Indiana',
    'Kentucky': 'Kentucky',
    'Michigan': 'Michigan',
    'Missouri': 'Missouri',
    'Multi - Base Market': 'Multi - Base Market',
    'Philadelphia': 'Philadelphia',
    'Pittsburgh': 'Pittsburgh',
    'Scranton': 'Scranton',
    'Wisconsin': 'Wisconsin',
    'Uniti-PA': 'Uniti-PA',
    'Multi - Expansion Market': 'Multi - Expansion Market',
    'Wisconsin Expansion': 'Wisconsin Expansion'
}


def transform_cllicode_last_part(es_value: Any, context: dict = None) -> Optional[float]:
    """
    Transform ES  to BBF CLLICode_Last_Part__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: CLLICode_Last_Part__c (CLLICode Last Part)
    BBF Type: double
    BBF Required: No

    AI Reasoning:
    ES does not have CLLI code component breakdown - would need to parse CLLI__c

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF CLLICode_Last_Part__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_full_address(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Output_Document_Address__c to BBF Full_Address__c.

    ES Field: Output_Document_Address__c (Output Document Address)
    ES Type: string

    BBF Field: Full_Address__c (Full Address)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES has formula field Output_Document_Address__c for formatted address

    Args:
        es_value: The source value from ES Output_Document_Address__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Full_Address__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_state(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES State__c to BBF State__c.

    ES Field: State__c (State)
    ES Type: picklist

    BBF Field: State__c (State)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES State__c stores abbreviations - may need expansion to full state name

    Args:
        es_value: The source value from ES State__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF State__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_unique_key(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Unique_Constraint_Check__c to BBF Unique_Key__c.

    ES Field: Unique_Constraint_Check__c (Unique Constraint Check)
    ES Type: string

    BBF Field: Unique_Key__c (Unique Key)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES uses Unique_Constraint_Check__c for address deduplication - similar purpose

    Args:
        es_value: The source value from ES Unique_Constraint_Check__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Unique_Key__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_strdir(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES  to BBF strDir__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: strDir__c (Street Direction)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES does not break out street direction separately - in Address__c

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF strDir__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_strsuffix(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES  to BBF strSuffix__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: strSuffix__c (Street Suffix)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES stores complete address - would need parsing for street suffix

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF strSuffix__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_streetno(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES  to BBF streetNo__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: streetNo__c (Street Number)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    ES stores full address in Address__c - would need parsing for street number

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF streetNo__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_address_api_status(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES  to BBF Address_API_Status__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: Address_API_Status__c (Address API Status)
    BBF Type: picklist
    BBF Required: No

    AI Reasoning:
    ES has Verified__c (boolean) and Address_Return_Code__c - needs transformation to picklist status

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Address_API_Status__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_address_validated_by(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Verification_Used__c to BBF Address_Validated_By__c.

    ES Field: Verification_Used__c (Verification Used)
    ES Type: picklist

    BBF Field: Address_Validated_By__c (Address Validated By)
    BBF Type: picklist
    BBF Required: No

    AI Reasoning:
    Maps to Verification_Used__c - picklist values partially overlap (SmartyStreets, Google)

    Args:
        es_value: The source value from ES Verification_Used__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Address_Validated_By__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Map picklist values using lookup dictionary
    if es_value is None:
        return None
    es_str = str(es_value).strip()
    return ADDRESS_VALIDATED_BY_MAP.get(es_str, es_str)  # Return original if no mapping


def transform_business_unit(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Dimension_4_Market__c to BBF Business_Unit__c.

    ES Field: Dimension_4_Market__c (Dimension 4 (Market))
    ES Type: picklist

    BBF Field: Business_Unit__c (Business Unit (text))
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    Text field - populate from Dimension_4_Market__c with transformation

    Args:
        es_value: The source value from ES Dimension_4_Market__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Business_Unit__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_match_key(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Unique_Constraint_Check__c to BBF Match_Key__c.

    ES Field: Unique_Constraint_Check__c (Unique Constraint Check)
    ES Type: string

    BBF Field: Match_Key__c (Match Key)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    Similar purpose - unique address matching key

    Args:
        es_value: The source value from ES Unique_Constraint_Check__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Match_Key__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_businessunit(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Dimension_4_Market__c to BBF businessUnit__c.

    ES Field: Dimension_4_Market__c (Dimension 4 (Market))
    ES Type: picklist

    BBF Field: businessUnit__c (Business Unit)
    BBF Type: picklist
    BBF Required: No

    AI Reasoning:
    ES uses Dimension_4_Market__c for market segmentation - BBF uses business unit model, requires value mapping

    Args:
        es_value: The source value from ES Dimension_4_Market__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF businessUnit__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Map picklist values using lookup dictionary
    if es_value is None:
        return None
    es_str = str(es_value).strip()
    return BUSINESSUNIT_MAP.get(es_str, es_str)  # Return original if no mapping


def transform_location_street(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Output_Document_Address__c to BBF Location_Street__c.

    ES Field: Output_Document_Address__c (Output Document Address)
    ES Type: string

    BBF Field: Location_Street__c (Street)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    BBF formula field - ES equivalent is Output_Document_Address__c

    Args:
        es_value: The source value from ES Output_Document_Address__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Location_Street__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_region(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES  to BBF Region__c.

    ES Field:  (nan)
    ES Type: nan

    BBF Field: Region__c (Region)
    BBF Type: picklist
    BBF Required: No

    AI Reasoning:
    ES does not have region concept - would need geographic calculation from State__c

    Args:
        es_value: The source value from ES 
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Region__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_market_mapping_name(es_value: Any, context: dict = None) -> Optional[Any]:
    """
    Transform ES Dimension_4_Market__c to BBF Market_Mapping_Name__c.

    ES Field: Dimension_4_Market__c (Dimension 4 (Market))
    ES Type: picklist

    BBF Field: Market_Mapping_Name__c (Market Mapping Name)
    BBF Type: reference
    BBF Required: No

    AI Reasoning:
    Could potentially derive from Dimension_4_Market__c

    Args:
        es_value: The source value from ES Dimension_4_Market__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Market_Mapping_Name__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


def transform_market(es_value: Any, context: dict = None) -> Optional[str]:
    """
    Transform ES Dimension_4_Market__c to BBF Market__c.

    ES Field: Dimension_4_Market__c (Dimension 4 (Market))
    ES Type: picklist

    BBF Field: Market__c (Market)
    BBF Type: string
    BBF Required: No

    AI Reasoning:
    Text field - map from Dimension_4_Market__c picklist values

    Args:
        es_value: The source value from ES Dimension_4_Market__c
        context: Optional dict with additional record context

    Returns:
        Transformed value suitable for BBF Market__c
    """
    # Handle null/empty input
    if es_value is None or (isinstance(es_value, str) and not es_value.strip()):
        return None

    # Pass through with basic type handling
    return es_value


# Transformer registry
TRANSFORMERS = {
    'CLLICode_Last_Part__c': transform_cllicode_last_part,
    'Full_Address__c': transform_full_address,
    'State__c': transform_state,
    'Unique_Key__c': transform_unique_key,
    'strDir__c': transform_strdir,
    'strSuffix__c': transform_strsuffix,
    'streetNo__c': transform_streetno,
    'Address_API_Status__c': transform_address_api_status,
    'Address_Validated_By__c': transform_address_validated_by,
    'Business_Unit__c': transform_business_unit,
    'Match_Key__c': transform_match_key,
    'businessUnit__c': transform_businessunit,
    'Location_Street__c': transform_location_street,
    'Region__c': transform_region,
    'Market_Mapping_Name__c': transform_market_mapping_name,
    'Market__c': transform_market
}

# Field mapping (BBF -> ES)
FIELD_MAPPING = {
    'Full_Address__c': 'Output_Document_Address__c',
    'State__c': 'State__c',
    'Unique_Key__c': 'Unique_Constraint_Check__c',
    'Address_Validated_By__c': 'Verification_Used__c',
    'Business_Unit__c': 'Dimension_4_Market__c',
    'Match_Key__c': 'Unique_Constraint_Check__c',
    'businessUnit__c': 'Dimension_4_Market__c',
    'Location_Street__c': 'Output_Document_Address__c',
    'Market_Mapping_Name__c': 'Dimension_4_Market__c',
    'Market__c': 'Dimension_4_Market__c'
}


def apply_transformers(es_record: dict) -> dict:
    """
    Apply all transformers to an ES record.

    Args:
        es_record: Dictionary of ES field values (field API name -> value)

    Returns:
        Dictionary of transformed BBF field values (BBF field API name -> value)
    """
    bbf_record = {}

    for bbf_field, transformer in TRANSFORMERS.items():
        es_field = FIELD_MAPPING.get(bbf_field)
        if es_field and es_field in es_record:
            try:
                bbf_record[bbf_field] = transformer(es_record[es_field], es_record)
            except Exception as e:
                # Log error but continue with other fields
                print(f"Warning: Transform failed for {bbf_field}: {e}")
                bbf_record[bbf_field] = None

    return bbf_record
